use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use crate::core::{GnawTreeWriter, EditOperation};
use std::fs;
use std::path::Path;
use crate::parser::TreeNode;

#[derive(Parser)]
#[command(name = "gnawtreewriter")]
#[command(about = "Tree-based code editor for LLM-assisted editing", long_about = None)]
pub struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand)]
enum Commands {
    /// Analyze file and show tree structure
    Analyze {
        /// Path to file or directory (supports multiple paths)
        paths: Vec<String>,
        /// Output format (json, compact, summary)
        #[arg(short, long, default_value = "json")]
        format: String,
    },
    /// List all nodes with paths in a file
    List {
        /// Path to file
        file_path: String,
        /// Filter by node type
        #[arg(short, long)]
        filter_type: Option<String>,
    },
    /// Find nodes matching criteria
    Find {
        /// Path to file or directory
        paths: Vec<String>,
        /// Filter by node type
        #[arg(short, long)]
        node_type: Option<String>,
        /// Filter by content (partial match)
        #[arg(short, long)]
        content: Option<String>,
    },
    /// Fuzzy edit - find and edit node without exact path
    FuzzyEdit {
        /// Path to file
        file_path: String,
        /// Fuzzy search query (type, content, or description)
        query: String,
        /// New content/code snippet
        content: String,
        /// Preview changes without applying them
        #[arg(short, long)]
        preview: bool,
        /// Filter by node type for more precise matching
        #[arg(short, long)]
        node_type: Option<String>,
    },
    /// Add property to QML component
    AddProperty {
        /// Path to QML file
        file_path: String,
        /// Query to find component (fuzzy)
        query: String,
        /// Property to add (e.g., "borderWidth: 2")
        property: String,
        /// Preview changes without applying them
        #[arg(short, long)]
        preview: bool,
    },
    /// Initialize project with basic configuration files
    Init {
        /// Path to project directory (defaults to current directory)
        #[arg(short, long)]
        path: Option<String>,
        /// Create files even if they exist
        #[arg(long)]
        force: bool,
    },
    /// Diagnose common issues in project
    Doctor {
        /// Path to project or file (defaults to current directory)
        #[arg(short, long)]
        path: Option<String>,
    },
    /// Lint files and show issues with severity levels
    Lint {
        /// Path to file or directory
        paths: Vec<String>,
        /// Output format (text, json)
        #[arg(short, long, default_value = "text")]
        format: String,
    },
    /// Show tree node at specific path
    Show {
        /// Path to file
        file_path: String,
        /// Tree path to node (e.g., "0.2.1")
        node_path: String,
    },
    /// Edit node at tree path
    Edit {
        /// Path to file
        file_path: String,
        /// Tree path to node
        node_path: String,
        /// New content/code snippet
        content: String,
        /// Preview changes without applying them
        #[arg(short, long)]
        preview: bool,
    },
    /// Insert new node
    Insert {
        /// Path to file
        file_path: String,
        /// Tree path to parent node
        parent_path: String,
        /// Insert position (0 = before, 1 = after, 2 = as child)
        position: usize,
        /// Content to insert
        content: String,
    },
    /// Delete node at tree path
    Delete {
        /// Path to file
        file_path: String,
        /// Tree path to node
        node_path: String,
    },
}

impl Cli {
    pub async fn run(self) -> Result<()> {
        match self.command {
            Commands::Analyze { paths, format: fmt } => {
                if paths.is_empty() {
                    eprintln!("Error: No paths provided");
                    std::process::exit(1);
                }

                let mut results = Vec::new();
                for path in &paths {
                    if let Err(e) = analyze_path(path, &fmt, &mut results) {
                        eprintln!("Error analyzing {}: {}", path, e);
                    }
                }

                if results.len() == 1 && fmt == "json" {
                    println!("{}", serde_json::to_string_pretty(&results[0])?);
                } else {
                    println!("{}", serde_json::to_string_pretty(&results)?);
                }
            }
            Commands::List { file_path, filter_type } => {
                let writer = GnawTreeWriter::new(&file_path)?;
                let tree = writer.analyze();
                list_nodes(tree, &file_path, filter_type.as_deref());
            }
            Commands::FuzzyEdit { file_path, query, content, preview, node_type } => {
                fuzzy_edit(&file_path, &query, &content, preview, node_type.as_deref())?;
            }
            Commands::AddProperty { file_path, query, property, preview } => {
                add_property(&file_path, &query, &property, preview)?;
            }
            Commands::Find { paths, node_type, content } => {
                if paths.is_empty() {
                    eprintln!("Error: No paths provided");
                    std::process::exit(1);
                }

                for path in &paths {
                    let path_obj = Path::new(path);
                    if path_obj.is_dir() {
                        find_in_directory(path_obj, node_type.as_deref(), content.as_deref())?;
                    } else {
                        find_in_file(path, node_type.as_deref(), content.as_deref())?;
                    }
                }
            }
            Commands::Lint { paths, format: fmt } => {
                if paths.is_empty() {
                    eprintln!("Error: No paths provided");
                    std::process::exit(1);
                }

                let mut issues = Vec::new();
                for path in &paths {
                    if let Err(e) = lint_path(path, &mut issues) {
                        eprintln!("Error linting {}: {}", path, e);
                    }
                }

                if fmt == "json" {
                    println!("{}", serde_json::to_string_pretty(&issues)?);
                } else {
                    for issue in &issues {
                        println!("{}:{}:{} {}: {} [{}]",
                            issue.file,
                            issue.line,
                            issue.column,
                            issue.severity,
                            issue.message,
                            issue.suggestion
                        );
                    }
                }

                let error_count = issues.iter().filter(|i| i.severity == "error").count();
                if error_count > 0 {
                    std::process::exit(1);
                }
            }
            Commands::Doctor { path } => {
                run_doctor(&path.unwrap_or_else(|| ".".to_string()));
            }
            Commands::Show { file_path, node_path } => {
                let writer = GnawTreeWriter::new(&file_path)?;
                let node = writer.show_node(&node_path)?;
                println!("{}", node);
            }
            Commands::Init { path, force } => {
                init_project(path.as_deref(), force)?;
            }
            Commands::Edit { file_path, node_path, content, preview } => {
                if preview {
                    let writer = GnawTreeWriter::new(&file_path)?;
                    let original = std::fs::read_to_string(&file_path)?;
                    let modified = writer.preview_edit(EditOperation::Edit {
                        node_path,
                        content: content.clone(),
                    })?;
                    let diff = generate_diff(&original, &modified, &file_path);
                    println!("{}", diff);
                } else {
                    let writer = GnawTreeWriter::new(&file_path)?;
                    writer.edit(EditOperation::Edit {
                        node_path,
                        content,
                    })?;
                    println!("Edited successfully");
                }
            }
            Commands::Insert { file_path, parent_path, position, content } => {
                let writer = GnawTreeWriter::new(&file_path)?;
                writer.edit(EditOperation::Insert {
                    parent_path,
                    position,
                    content,
                })?;
                println!("Inserted successfully");
            }
            Commands::Delete { file_path, node_path } => {
                let writer = GnawTreeWriter::new(&file_path)?;
                writer.edit(EditOperation::Delete { node_path })?;
                println!("Deleted successfully");
            }
        }
        Ok(())
    }

}

#[derive(Debug, Clone, serde::Serialize)]
struct LintIssue {
    file: String,
    line: usize,
    column: usize,
    severity: String,
    message: String,
    suggestion: String,
}

#[derive(Debug, Clone)]
struct MatchCandidate {
    path: String,
    node_type: String,
    content: String,
    line: usize,
    score: f64,
    match_reason: String,
}

impl MatchCandidate {
    fn new(path: String, node_type: String, content: String, line: usize) -> Self {
        Self {
            path,
            node_type,
            content,
            line,
            score: 0.0,
            match_reason: String::new(),
        }
    }

    fn with_score(mut self, score: f64, reason: String) -> Self {
        self.score = score;
        self.match_reason = reason;
        self
    }
}

fn lint_path(path: &str, issues: &mut Vec<LintIssue>) -> Result<()> {
    let path_obj = Path::new(path);

    if path_obj.is_dir() {
        lint_directory(path_obj, issues)?;
    } else {
        let writer = GnawTreeWriter::new(path)?;
        let tree = writer.analyze();
        check_tree_issues(&tree, path, issues);
    }

    Ok(())
}

fn lint_directory(dir: &Path, issues: &mut Vec<LintIssue>) -> Result<()> {
    let entries = fs::read_dir(dir)
        .context(format!("Failed to read directory: {}", dir.display()))?;

    for entry in entries {
        let entry = entry?;
        let path = entry.path();

        if path.is_file() {
            if let Some(ext) = path.extension() {
                if is_supported_extension(ext.to_str().unwrap_or("")) {
                    if let Some(path_str) = path.to_str() {
                        if let Err(e) = lint_path(path_str, issues) {
                            eprintln!("Error linting {}: {}", path.display(), e);
                        }
                    }
                }
            }
        } else if path.is_dir() {
            lint_directory(&path, issues)?;
        }
    }

    Ok(())
}

fn check_tree_issues(tree: &TreeNode, file_path: &str, issues: &mut Vec<LintIssue>) {
    check_node(tree, file_path, issues);

    for child in &tree.children {
        check_tree_issues(child, file_path, issues);
    }
}

fn check_node(node: &TreeNode, file_path: &str, issues: &mut Vec<LintIssue>) {
    if node.node_type == "Property" {
        if node.content.trim().is_empty() {
            issues.push(LintIssue {
                file: file_path.to_string(),
                line: node.start_line,
                column: 1,
                severity: "warning".to_string(),
                message: "Empty property found".to_string(),
                suggestion: "Remove or add content to property".to_string(),
            });
        }

        if node.content.len() > 200 {
            issues.push(LintIssue {
                file: file_path.to_string(),
                line: node.start_line,
                column: 1,
                severity: "info".to_string(),
                message: "Property is very long".to_string(),
                suggestion: "Consider splitting into multiple properties".to_string(),
            });
        }
    }

    if node.node_type == "Text" && node.content.len() > 100 {
        issues.push(LintIssue {
            file: file_path.to_string(),
            line: node.start_line,
            column: 1,
            severity: "info".to_string(),
            message: "Long text content".to_string(),
            suggestion: "Consider using translation keys".to_string(),
        });
    }
}

fn list_nodes(tree: &TreeNode, file_path: &str, filter_type: Option<&str>) {
    print_node(tree, file_path, filter_type, 0);

    for child in &tree.children {
        list_nodes_helper(child, file_path, filter_type, 1);
    }
}

fn list_nodes_helper(node: &TreeNode, file_path: &str, filter_type: Option<&str>, depth: usize) {
    print_node(node, file_path, filter_type, depth);

    for child in &node.children {
        list_nodes_helper(child, file_path, filter_type, depth + 1);
    }
}

fn print_node(node: &TreeNode, _file_path: &str, filter_type: Option<&str>, depth: usize) {
    if let Some(filter) = filter_type {
        if node.node_type != filter {
            return;
        }
    }

    let indent = "  ".repeat(depth);
    let content_preview = if node.content.len() > 50 {
        format!("{}\
...", &node.content[..50])
    } else {
        node.content.clone()
    };

    let line_info = if node.end_line != node.start_line {
        format!("-{}", node.end_line)
    } else {
        String::new()
    };

    let content_info = if !content_preview.is_empty() {
        format!(": {}", content_preview)
    } else {
        String::new()
    };

    println!("{}{} [{}:{}{}] {}",
        indent,
        node.path,
        node.node_type,
        node.start_line,
        line_info,
        content_info
    );
}

fn find_in_file(path: &str, node_type: Option<&str>, content: Option<&str>) -> Result<()> {
    let writer = GnawTreeWriter::new(path)?;
    let tree = writer.analyze();
    find_in_tree(tree, path, node_type, content);
    Ok(())
}

fn find_in_directory(dir: &Path, node_type: Option<&str>, content: Option<&str>) -> Result<()> {
    let entries = fs::read_dir(dir)?;

    for entry in entries {
        let entry = entry?;
        let path = entry.path();

        if path.is_file() {
            if let Some(ext) = path.extension() {
                if is_supported_extension(ext.to_str().unwrap_or("")) {
                    if let Some(path_str) = path.to_str() {
                        find_in_file(path_str, node_type, content)?;
                    }
                }
            }
        } else if path.is_dir() {
            find_in_directory(&path, node_type, content)?;
        }
    }

    Ok(())
}

fn add_property(file_path: &str, node_path: &str, property: &str, preview: bool) -> Result<()> {
    let writer = GnawTreeWriter::new(file_path)?;
    let original = std::fs::read_to_string(file_path)?;

    if preview {
        let modified = writer.preview_edit(EditOperation::Insert {
            parent_path: node_path.to_string(),
            position: 2,
            content: property.to_string(),
        })?;
        let diff = generate_diff(&original, &modified, file_path);
        println!("{}", diff);
    } else {
        writer.edit(EditOperation::Insert {
            parent_path: node_path.to_string(),
            position: 2,
            content: property.to_string(),
        })?;
        println!("Added property '{}' to {}", property, node_path);
    }

    Ok(())
}

fn fuzzy_edit(file_path: &str, query: &str, new_content: &str, preview: bool, filter_type: Option<&str>) -> Result<()> {
    let writer = GnawTreeWriter::new(file_path)?;
    let tree = writer.analyze();

    let query_lower = query.to_lowercase();
    let mut candidates = Vec::new();

    collect_candidates(tree, &query_lower, filter_type, &mut candidates);

    if candidates.is_empty() {
        eprintln!("No matches found for query: {}", query);
        return Ok(())
    }

    candidates.sort_by(|a, b| {
        b.score.partial_cmp(&a.score).unwrap_or(std::cmp::Ordering::Equal)
    });

    let best = &candidates[0];

    if candidates.len() > 1 && (candidates[1].score - best.score).abs() < 10.0 {
        println!("Found {} matches for '{}':", candidates.len(), query);
        for (i, cand) in candidates.iter().take(5).enumerate() {
            println!("  {}. {} [{}:{}{}] {} - {:.1}% match - {}",
                i + 1,
                cand.path,
                cand.node_type,
                cand.line,
                if cand.content.len() > 50 { format!("{}\
...", &cand.content[..50]) } else { cand.content.clone() },
                cand.score,
                cand.match_reason
            );
        }
        println!("Using best match: {}", best.path);
        println!();
    } else {
        println!("Matched: {} [{}:{}{}] - {:.1}% ({})",
            best.path,
            best.node_type,
            best.line,
            best.score,
            best.match_reason
        );
    }

    if preview {
        let original = std::fs::read_to_string(file_path)?;
        let modified = writer.preview_edit(EditOperation::Edit {
            node_path: best.path.clone(),
            content: new_content.to_string(),
        })?;
        let diff = generate_diff(&original, &modified, file_path);
        println!("{}", diff);
    } else {
        writer.edit(EditOperation::Edit {
            node_path: best.path.clone(),
            content: new_content.to_string(),
        })?;
        println!("Edited successfully");
    }

    Ok(())
}

fn collect_candidates(tree: &TreeNode, query: &str, filter_type: Option<&str>, candidates: &mut Vec<MatchCandidate>) {
    if let Some(filter) = filter_type {
        if tree.node_type == filter {
            evaluate_node(tree, query, candidates);
        }
    } else {
        evaluate_node(tree, query, candidates);
    }

    for child in &tree.children {
        collect_candidates(child, query, filter_type, candidates);
    }
}

fn evaluate_node(node: &TreeNode, query: &str, candidates: &mut Vec<MatchCandidate>) {
    if node.path == "root" {
        return;
    }

    let content_lower = node.content.to_lowercase();
    let node_type_lower = node.node_type.to_lowercase();

    let mut score = 0.0;
    let mut reasons: Vec<String> = Vec::new();

    if content_lower.contains(query) {
        score += 90.0;
        reasons.push("content match".to_string());
    }

    if node_type_lower.contains(query) {
        score += 80.0;
        reasons.push("type match".to_string());
    }

    let words: Vec<&str> = query.split_whitespace().collect();
    let content_words: Vec<&str> = content_lower.split_whitespace().collect();

    for word in &words {
        if content_words.iter().any(|cw| cw.contains(word)) {
            score += 30.0;
            reasons.push(format!("word match: {}", word));
        }
    }

    if !node.content.trim().is_empty() && content_lower.starts_with(query) {
        score += 40.0;
        reasons.push("prefix match".to_string());
    }

    let distance = levenshtein_distance(&content_lower, query);
    let max_len = content_lower.len().max(query.len());
    if max_len > 0 {
        let similarity = 1.0 - (distance as f64 / max_len as f64);
        if similarity > 0.7 {
            score += similarity * 50.0;
            reasons.push(format!("similarity: {:.1}%", similarity * 100.0));
        }
    }

    if !node.content.trim().is_empty() && content_lower.starts_with(query.chars().next().unwrap_or(' ')) {
        score += 15.0;
        reasons.push("first char match".to_string());
    }

    if score > 0.0 {
        let reason = if reasons.len() > 2 {
            format!(