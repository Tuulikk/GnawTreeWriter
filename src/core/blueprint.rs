use anyhow::Result;
use std::collections::{HashMap, HashSet};
use std::path::{Path, PathBuf};
use crate::llm::RelationalIndexer;
use colored::Colorize;

pub struct BlueprintEngine {
    project_root: PathBuf,
}

pub struct ProjectBlueprint {
    pub total_files: usize,
    pub clusters: HashMap<String, Vec<String>>,
    pub connections: Vec<(String, String)>,
    pub entry_points: Vec<String>,
}

impl BlueprintEngine {
    pub fn new(project_root: &Path) -> Self {
        Self {
            project_root: project_root.to_path_buf(),
        }
    }

    pub fn generate(&self) -> Result<ProjectBlueprint> {
        let mut indexer = RelationalIndexer::new(&self.project_root);
        let mut graphs = indexer.load_all_graphs()?;
        
        if graphs.is_empty() {
            let src_path = self.project_root.join("src");
            let scan_target = if src_path.exists() { src_path } else { self.project_root.clone() };
            
            println!("üîç No architectural graphs found. Performing initial scan of '{}'...", scan_target.display());
            graphs = indexer.index_directory(&scan_target)?;
        }
        
        let mut blueprint = ProjectBlueprint {
            total_files: graphs.len(),
            clusters: HashMap::new(),
            connections: Vec::new(),
            entry_points: Vec::new(),
        };

        let mut seen_connections = HashSet::new();

        for graph in graphs {
            let path = Path::new(&graph.file_path);
            let file_name = path.file_name().and_then(|s| s.to_str()).unwrap_or("unknown");
            
            // 1. Clustering by directory
            let parent = path.parent()
                .and_then(|p| p.strip_prefix(&self.project_root).ok())
                .and_then(|p| p.to_str())
                .unwrap_or("root");
            
            blueprint.clusters.entry(parent.to_string())
                .or_default()
                .push(file_name.to_string());

            // 2. Connections (Relations)
            for rel in graph.relations {
                if let Some(to_file) = rel.to_file {
                    let to_path = Path::new(&to_file);
                    let to_name = to_path.file_name().and_then(|s| s.to_str()).unwrap_or("unknown");
                    
                    let conn = (file_name.to_string(), to_name.to_string());
                    if !seen_connections.contains(&conn) && conn.0 != conn.1 {
                        blueprint.connections.push(conn.clone());
                        seen_connections.insert(conn);
                    }
                }
            }

            // 3. Entry point detection
            if file_name == "main.rs" || file_name == "main.py" || file_name == "index.ts" || file_name == "lib.rs" {
                blueprint.entry_points.push(file_name.to_string());
            }
        }

        Ok(blueprint)
    }

    pub fn render_to_terminal(&self, blueprint: &ProjectBlueprint) {
        println!("\n{}", "üèóÔ∏è  Project Blueprint".bold().bright_white().on_blue());
        println!("{} files indexed across {} clusters\n", blueprint.total_files, blueprint.clusters.len());

        println!("{}", "üìÅ Clusters:".bold().yellow());
        for (cluster, files) in &blueprint.clusters {
            println!("  {} ({})", cluster.cyan(), files.len());
            if files.len() < 10 {
                println!("    ‚îî‚îÄ {}", files.join(", ").dimmed());
            }
        }

        println!("\n{}", "üîó Key Relations:".bold().yellow());
        for (from, to) in blueprint.connections.iter().take(15) {
            println!("  {} {} {}", from.white(), "‚îÄ‚îÄ‚ñ∂".dimmed(), to.bright_white());
        }
        if blueprint.connections.len() > 15 {
            println!("  ... and {} more connections", blueprint.connections.len() - 15);
        }

        println!("\n{}", "üöÄ Entry Points:".bold().yellow());
        for ep in &blueprint.entry_points {
            println!("  ‚Ä¢ {}", ep.green().bold());
        }
        println!();
    }

    pub fn render_to_markdown(&self, blueprint: &ProjectBlueprint) -> String {
        let mut md = String::new();
        md.push_str("# üèóÔ∏è Project Blueprint\n\n");
        md.push_str(&format!("*Generated by GnawTreeWriter on {}*\n\n", chrono::Local::now().format("%Y-%m-%d %H:%M:%S")));
        
        md.push_str(&format!("**Total Files:** {}\n", blueprint.total_files));
        md.push_str(&format!("**Clusters:** {}\n\n", blueprint.clusters.len()));

        md.push_str("## üìÅ Architectural Clusters\n\n");
        for (cluster, files) in &blueprint.clusters {
            md.push_str(&format!("### üì¶ {}\n", cluster));
            md.push_str(&format!("- **Files ({}):** {}\n\n", files.len(), files.join(", ")));
        }

        md.push_str("## üîó Key Relations\n\n");
        md.push_str("| From | Relation | To |\n");
        md.push_str("| :--- | :---: | :--- |\n");
        for (from, to) in &blueprint.connections {
            md.push_str(&format!("| `{}` | ‚îÄ‚îÄ‚ñ∂ | `{}` |\n", from, to));
        }
        md.push_str("\n");

        md.push_str("## üöÄ Detected Entry Points\n\n");
        for ep in &blueprint.entry_points {
            md.push_str(&format!("- ‚úÖ `{}`\n", ep));
        }
        
        md.push_str("\n---\n*Gnag vidare! Allting √§r relativt.*");
        md
    }
}
