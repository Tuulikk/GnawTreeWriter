use anyhow::{Result, anyhow};

pub struct ScaffoldEngine;

impl Default for ScaffoldEngine {
    fn default() -> Self {
        Self::new()
    }
}

impl ScaffoldEngine {
    pub fn new() -> Self {
        Self
    }

    pub fn generate(&self, schema: &str) -> Result<String> {
        let (lang, structure) = schema.split_once(':')
            .ok_or_else(|| anyhow!("Invalid schema format. Expected 'lang:structure'"))?;

        match lang.to_lowercase().as_str() {
            "rust" => self.generate_rust(structure),
            "python" => self.generate_python(structure),
            _ => Err(anyhow!("Unsupported language for scaffolding: {}", lang)),
        }
    }

    fn generate_rust(&self, structure: &str) -> Result<String> {
        let mut output = String::new();
        output.push_str("// Generated by GnawTreeWriter Scaffolding\n\n");

        // Simple parsing of mod(name:X, struct:Y, fn:Z)
        let parts = self.parse_structure(structure);
        
        for (kind, name) in parts {
            match kind.as_str() {
                "mod" => output.push_str(&format!("pub mod {} {{\n    // ...\n}}\n\n", name)),
                "struct" => output.push_str(&format!("pub struct {} {{\n    // TODO: Add fields\n}}\n\n", name)),
                "fn" => output.push_str(&format!("pub fn {}() {{\n    unimplemented!()\n}}\n\n", name)),
                "impl" => output.push_str(&format!("impl {} {{\n    // ...\n}}\n\n", name)),
                _ => {{}}
            }
        }

        Ok(output)
    }

    fn generate_python(&self, structure: &str) -> Result<String> {
        let mut output = String::new();
        output.push_str("# Generated by GnawTreeWriter Scaffolding\n\n");

        let parts = self.parse_structure(structure);
        
        for (kind, name) in parts {
            match kind.as_str() {
                "class" => output.push_str(&format!("class {}:\n    def __init__(self):\n        pass\n\n", name)),
                "fn" => output.push_str(&format!("def {}():\n    pass\n\n", name)),
                _ => {{}}
            }
        }

        Ok(output)
    }

    fn parse_structure(&self, structure: &str) -> Vec<(String, String)> {
        // Very basic parser for: type(name:X), type(name:Y)
        // Improvements: Handle nested structures in the future
        let mut results = Vec::new();
        
        // Remove outer parens if any, e.g., mod(name:foo)
        let clean = structure.trim_end_matches(')');
        let (kind, inner) = match clean.split_once('(') {
            Some(res) => res,
            None => return vec![(clean.to_string(), "unnamed".to_string())],
        };

        for part in inner.split(',') {
            let part = part.trim();
            if part.starts_with("name:") {
                let name = part.strip_prefix("name:").unwrap_or("unnamed");
                results.push((kind.to_string(), name.to_string()));
            } else if let Some((k, n)) = part.split_once(':') {
                results.push((k.to_string(), n.to_string()));
            }
        }

        if results.is_empty() {
            results.push((kind.to_string(), "unnamed".to_string()));
        }

        results
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rust_scaffold() {
        let engine = ScaffoldEngine::new();
        let code = engine.generate("rust:struct(name:Config)").unwrap();
        assert!(code.contains("pub struct Config"));
    }
}

