use anyhow::{Result, anyhow};

#[derive(Debug, Clone)]
struct ScaffoldNode {
    kind: String,
    name: String,
    children: Vec<ScaffoldNode>,
}

pub struct ScaffoldEngine;

impl Default for ScaffoldEngine {
    fn default() -> Self {
        Self::new()
    }
}

impl ScaffoldEngine {
    pub fn new() -> Self {
        Self
    }

    pub fn generate(&self, schema: &str) -> Result<String> {
        let (lang, structure) = schema.split_once(':')
            .ok_or_else(|| anyhow!("Invalid schema format. Expected 'lang:structure'"))?;

        let nodes = self.parse_recursive(structure)?;

        match lang.to_lowercase().as_str() {
            "rust" => Ok(self.generate_rust(&nodes, 0)),
            "python" => Ok(self.generate_python(&nodes, 0)),
            _ => Err(anyhow!("Unsupported language for scaffolding: {}", lang)),
        }
    }

    fn generate_rust(&self, nodes: &[
ScaffoldNode], depth: usize) -> String {
        let mut output = String::new();
        let indent = "    ".repeat(depth);

        if depth == 0 {
            output.push_str("// Generated by GnawTreeWriter Scaffolding\n\n");
        }

        for node in nodes {
            match node.kind.as_str() {
                "mod" => {
                    output.push_str(&format!("{}pub mod {} {{`", indent, node.name));
                    output.push_str(&self.generate_rust(&node.children, depth + 1));
                    output.push_str(&format!("{}}}
\n", indent));
                }
                "struct" => {
                    output.push_str(&format!("{}pub struct {} {{
", indent, node.name));
                    for child in &node.children {
                        output.push_str(&format!("{}    pub {}: String,\n", indent, child.name));
                    }
                    if node.children.is_empty() {
                        output.push_str(&format!("{}    // TODO: Add fields\n", indent));
                    }
                    output.push_str(&format!("{}}}
\n", indent));
                }
                "fn" => {
                    output.push_str(&format!("{}pub fn {}() {{
", indent, node.name));
                    output.push_str(&self.generate_rust(&node.children, depth + 1));
                    if node.children.is_empty() {
                        output.push_str(&format!("{}    unimplemented!()\n", indent));
                    }
                    output.push_str(&format!("{}}}
\n", indent));
                }
                "impl" => {
                    output.push_str(&format!("{}impl {} {{
", indent, node.name));
                    output.push_str(&self.generate_rust(&node.children, depth + 1));
                    output.push_str(&format!("{}}}
\n", indent));
                }
                _ => {
                    output.push_str(&format!("{}// {} {}
", indent, node.kind, node.name));
                }
            }
        }

        output
    }

    fn generate_python(&self, nodes: &[
ScaffoldNode], depth: usize) -> String {
        let mut output = String::new();
        let indent = "    ".repeat(depth);

        if depth == 0 {
            output.push_str("# Generated by GnawTreeWriter Scaffolding\n\n");
        }

        for node in nodes {
            match node.kind.as_str() {
                "class" => {
                    output.push_str(&format!("{}class {}:\n", indent, node.name));
                    if node.children.is_empty() {
                        output.push_str(&format!("{}    pass\n\n", indent));
                    } else {
                        output.push_str(&self.generate_python(&node.children, depth + 1));
                    }
                }
                "fn" => {
                    output.push_str(&format!("{}def {}():\n", indent, node.name));
                    if node.children.is_empty() {
                        output.push_str(&format!("{}    pass\n\n", indent));
                    } else {
                        output.push_str(&self.generate_python(&node.children, depth + 1));
                    }
                }
                _ => {
                    output.push_str(&format!("{}# {} {}
", indent, node.kind, node.name));
                }
            }
        }

        output
    }

    fn parse_recursive(&self, structure: &str) -> Result<Vec<ScaffoldNode>> {
        let mut nodes = Vec::new();
        let mut current_pos = 0;
        let s = structure.trim();

        while current_pos < s.len() {
            let remaining = &s[current_pos..].trim_start();
            if remaining.is_empty() { break; }

            // Find next node: type:name(args) OR type(args)
            let type_end = remaining.find('(').unwrap_or(remaining.len());
            let type_part = remaining[..type_end].trim();
            
            let (kind, mut name) = match type_part.split_once(':') {
                Some((k, n)) => (k.to_string(), n.to_string()),
                None => (type_part.to_string(), "unnamed".to_string()),
            };

            let mut children = Vec::new();
            let mut node_total_len = type_end;

            if type_end < remaining.len() {
                // We have args in parens
                let mut paren_count = 0;
                let mut paren_end = 0;
                let mut found_paren_end = false;
                for (i, c) in remaining[type_end..].chars().enumerate() {
                    if c == '(' { paren_count += 1; }
                    else if c == ')' { paren_count -= 1; }
                    
                    if paren_count == 0 {
                        paren_end = type_end + i;
                        found_paren_end = true;
                        break;
                    }
                }

                if !found_paren_end {
                    anyhow::bail!("Unbalanced parentheses in schema at: {}", remaining);
                }

                let inner = &remaining[type_end + 1 .. paren_end];
                node_total_len = paren_end + 1;

                // Parse inner: name:X, children:[...]
                if let Some(name_start) = inner.find("name:") {
                    let after_name = &inner[name_start + 5..];
                    let name_end = after_name.find(',').unwrap_or(after_name.len());
                    name = after_name[..name_end].trim().to_string();
                }

                if let Some(children_start) = inner.find("children:[") {
                    let children_content_start = children_start + 10;
                    let mut bracket_count = 1;
                    let mut children_end = 0;
                    let mut found_bracket_end = false;
                    for (i, c) in inner[children_content_start..].chars().enumerate() {
                        if c == '[' { bracket_count += 1; }
                        else if c == ']' { bracket_count -= 1; }
                        
                        if bracket_count == 0 {
                            children_end = children_content_start + i;
                            found_bracket_end = true;
                            break;
                        }
                    }
                    
                    if !found_bracket_end {
                        anyhow::bail!("Unbalanced brackets in children list at: {}", inner);
                    }

                    let children_str = &inner[children_content_start .. children_end];
                    children = self.parse_recursive(children_str)?;
                }
            }

            nodes.push(ScaffoldNode { kind, name, children });
            
            // Advance position in the main string
            let advance = s[current_pos..].find(remaining).unwrap() + node_total_len;
            current_pos += advance;

            // Skip comma
            let next_remaining = &s[current_pos..].trim_start();
            if next_remaining.starts_with(',') {
                current_pos += s[current_pos..].find(',').unwrap() + 1;
            }
        }

        Ok(nodes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_nested_scaffold() {
        let engine = ScaffoldEngine::new();
        // Support both type:name(args) and type(name:args)
        let schema = "rust:mod(name:auth, children:[struct:Profile(), fn:login(name:execute)])";
        let code = engine.generate(schema).unwrap();
        assert!(code.contains("pub mod auth"));
        assert!(code.contains("pub struct Profile"));
        assert!(code.contains("pub fn execute"));
    }
}